<!DOCTYPE html>
<html lang="zh-CN">

<!-- Head tag -->
<head>

    <meta charset="utf-8"/>
    <meta http-equiv="X-UA-Compatible" content="IE=edge"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>

    <!--Description-->

    

    
        <meta name="description" content="description here"/>
    

    <!--Author-->
    
        <meta name="author" content="cloud"/>
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="Shell_lab"/>
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="description here"/>
    

    <!--Open Graph Site Name-->
        <meta property="og:site_name" content="Cumubloomusing"/>

    <!--Type page-->
    
        <meta property="og:type" content="article"/>
    

    <!--Page Cover-->
    
    
        <meta property="og:image" content="http://example.comimg/index_bg.jpg"/>
    

        <meta name="twitter:card" content="summary_large_image"/>

    

    
        <meta name="twitter:image" content="http://example.comimg/index_bg.jpg"/>
    

    <!-- Title -->
    
    <title>Shell_lab - Cumubloomusing</title>

    <!-- Bootstrap Core CSS -->
    <link href="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/css/bootstrap.min.css" rel="stylesheet"/>

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/style.css">


    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/>
    <link href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" rel="stylesheet" type="text/css"/>
    <link href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css"/>

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
    <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet"/>

    <!-- Google Analytics -->
    


    <!-- favicon -->
    
    <link rel="icon" href="img/sacabam.ico"/>
    

<meta name="generator" content="Hexo 6.3.0"></head>


<body>

    <!-- Menu -->
    <!-- Navigation -->
<nav class="navbar navbar-default navbar-custom navbar-fixed-top">
    <div class="container-fluid">
        <!-- Brand and toggle get grouped for better mobile display -->
        <div class="navbar-header page-scroll">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a class="navbar-brand" href="/">ε(*´･ω･)з</a>
        </div>

        <!-- Collect the nav links, forms, and other content for toggling -->
        <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
            <ul class="nav navbar-nav navbar-right">
                
                    <li>
                        <a href="/">
                            
                                Home
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/archives">
                            
                                Archives
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/tags">
                            
                                Tags
                            
                        </a>
                    </li>
                
                    <li>
                        <a href="/categories">
                            
                                Categories
                            
                        </a>
                    </li>
                
                    <li>
                        <a target="_blank" rel="noopener" href="https://github.com/yanchenjisui/yanchenjisui.github.io">
                            
                                <i class="fa fa-github fa-stack-2x"></i>
                            
                        </a>
                    </li>
                
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
    <!-- /.container -->
</nav>

    <!-- Main Content -->
    <!-- Page Header -->
<!-- Set your background image for this header in your post front-matter: cover -->

<header class="intro-header" style="background-image: url('/img/index_bg.jpg')">
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <div class="post-heading">
                    <h1>Shell_lab</h1>
                    
                    <span class="meta">
                        <!-- Date and Author -->
                        
                            Posted by cloudy on
                        
                        
                            2023-10-01
                        
                    </span>
                </div>
            </div>
        </div>
    </div>
</header>

<!-- Post Content -->
<article>
    <div class="container">
        <div class="row">

            <!-- Tags and categories -->
           
                <div class="col-lg-4 col-lg-offset-2 col-md-5 col-md-offset-1 post-tags">
                    
                        


<a href="/tags/可持续发展式剿灭打法/">#可持续发展式剿灭打法</a> <a href="/tags/主包该醒了，剿灭都漏两还是抄个挂机作业吧/">#主包该醒了，剿灭都漏两还是抄个挂机作业吧</a> <a href="/tags/主包打10难度是因为还没到15/">#主包打10难度是因为还没到15</a>


                    
                </div>
                <div class="col-lg-4 col-md-5 post-categories">
                    
                        

<a href="/categories/cs实验/">cs实验</a>

                    
                </div>
            

            <!-- Gallery -->
            

            <!-- Post Main Content -->
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <h1 id="Shell-Lab"><a href="#Shell-Lab" class="headerlink" title="Shell_Lab"></a>Shell_Lab</h1><h2 id="一、实验目的"><a href="#一、实验目的" class="headerlink" title="一、实验目的"></a>一、实验目的</h2><p>完善文件夹中tsh.c文件中的7个函数，实现一个支持任务功能的shell。</p>
<h2 id="二、实验准备"><a href="#二、实验准备" class="headerlink" title="二、实验准备"></a>二、实验准备</h2><p>要实现的七个函数如下：（这些函数具体要实现或已实现的功能见注释）</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void eval(char *cmdline);//解析命令(大概一个预处理的样子)</span><br><span class="line">int builtin_cmd(char **argv);//解析和执行bulidin命令，包括quit,fg,bg,jobs</span><br><span class="line">void do_bgfg(char **argv);//执行bg和fg操作</span><br><span class="line">void waitfg(pid_t pid);//实现阻塞等待前台程序运行结束</span><br><span class="line">void sigchld_handler(int sig);//SIGCHID信号处理函数</span><br><span class="line">void sigtstp_handler(int sig);//响应 SIGINT (ctrl-c) 信号 </span><br><span class="line">void sigint_handler(int sig);//响应 SIGTSTP (ctrl-z) 信号</span><br></pre></td></tr></table></figure>

<p>同时tsh.c中还提供了许多已经完善好的函数供我们使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">//获取参数列表，判断是否为后台运行命令,将结果返还给eval函数。</span><br><span class="line">int parseline(const char *cmdline, char **argv);</span><br><span class="line">//处理SIGQUIT信号</span><br><span class="line">void sigquit_handler(int sig);</span><br><span class="line"></span><br><span class="line">//清除job结构体（全部置零） </span><br><span class="line">void clearjob(struct job_t *job);</span><br><span class="line">////初始化任务列表jobs[]</span><br><span class="line">void initjobs(struct job_t *jobs);</span><br><span class="line">//返回jobs链表中最大的jid号</span><br><span class="line">int maxjid(struct job_t *jobs);</span><br><span class="line">//向任务列表添加一个任务</span><br><span class="line">int addjob(struct job_t *jobs, pid_t pid, int state, char *cmdline);</span><br><span class="line">//从任务列表中删除指定pid的任务</span><br><span class="line">int deletejob(struct job_t *jobs, pid_t pid);</span><br><span class="line">//返回当前前台运行job的pid号</span><br><span class="line">pid_t fgpid(struct job_t *jobs);</span><br><span class="line">//根据pid找到对应的job </span><br><span class="line">struct job_t *getjobpid(struct job_t *jobs, pid_t pid);</span><br><span class="line">//根据jid找到对应的job</span><br><span class="line">struct job_t *getjobjid(struct job_t *jobs, int jid);</span><br><span class="line">//根据pid找到jid</span><br><span class="line">int pid2jid(pid_t pid);</span><br><span class="line">//打印任务列表</span><br><span class="line">void listjobs(struct job_t *jobs);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">//--------下面的部分不用管，和实验关系不大--------//</span><br><span class="line">//打印帮助信息</span><br><span class="line">void usage(void);</span><br><span class="line">//两种错误</span><br><span class="line">void unix_error(char *msg);</span><br><span class="line">void app_error(char *msg);</span><br><span class="line">//定义的一种类型</span><br><span class="line">typedef void handler_t(int);</span><br><span class="line">//sig***_hander函数的包装</span><br><span class="line">handler_t *Signal(int signum, handler_t *handler);</span><br></pre></td></tr></table></figure>

<p>接着tsh.c中还定义了一些其他内容：</p>
<p>宏：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* Misc manifest constants */</span><br><span class="line">#define MAXLINE 1024   /* max line size */</span><br><span class="line">#define MAXARGS 128    /* max args on a command line */</span><br><span class="line">#define MAXJOBS 16     /* max jobs at any point in time */</span><br><span class="line">#define MAXJID 1 &lt;&lt; 16 /* max job ID */</span><br></pre></td></tr></table></figure>

<p>四种进程状态：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/* Job states */</span><br><span class="line">#define UNDEF 0 /* undefined */</span><br><span class="line">#define FG 1    /* running in foreground */</span><br><span class="line">#define BG 2    /* running in background */</span><br><span class="line">#define ST 3    /* stopped */</span><br></pre></td></tr></table></figure>

<p>全局变量：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/* Global variables */</span><br><span class="line">extern char **environ;   /* defined in libc */</span><br><span class="line">char prompt[] = &quot;tsh&gt; &quot;; /* command line prompt (DO NOT CHANGE) */</span><br><span class="line">int verbose = 0;         /* if true, print additional output */</span><br><span class="line">int nextjid = 1;         /* next job ID to allocate */</span><br><span class="line">char sbuf[MAXLINE];      /* for composing sprintf messages */</span><br></pre></td></tr></table></figure>

<p>job_t的任务的类，并且创建了jobs[]数组：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">struct job_t</span><br><span class="line">&#123;                          /* The job struct */</span><br><span class="line">    pid_t pid;             /* job PID */</span><br><span class="line">    int jid;               /* job ID [1, 2, ...] */</span><br><span class="line">    int state;             /* UNDEF, BG, FG, or ST */</span><br><span class="line">    char cmdline[MAXLINE]; /* command line */</span><br><span class="line">&#125;;</span><br><span class="line">struct job_t jobs[MAXJOBS]; /* The job list */</span><br></pre></td></tr></table></figure>

<p>实验的具体操作流程：</p>
<p>编写完善tsh.c中的7个函数，执行make指令编译tsh.c得到可执行文件tsh。然后执行make rtest01和make test01进行比对，如果我们的执行结果与参考结果一致，则实现正确。我们的任务是通过所有16个test(test的内容见trace.txt)。</p>
<p>接着了解一下测试文件中（trace.txt）符号和命令的定义：</p>
<p>符号：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">空格：分隔指令作用</span><br><span class="line">&amp;：如果命令以&amp;结尾，表示标该作业在后台运行</span><br><span class="line">#：直接打印#后一行的文本内容</span><br><span class="line">%：后接一个整数，表示job的ID号。</span><br></pre></td></tr></table></figure>

<p>命令：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jobs: 列出正在运行和停止的后台作业</span><br><span class="line">bg &lt;job&gt;: 将停止的后台作业更改为正在运行的后台作业</span><br><span class="line">fg &lt;job&gt;:将已停止或正在运行的后台作业更改为前台正在运行的作业</span><br><span class="line">kill : 终止一个作业</span><br></pre></td></tr></table></figure>

<p>用户程序：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myint程序：函数睡眠，使程序睡眠n秒，运行结束后不会自动退出，并会检测系统错误；</span><br><span class="line">myspin程序：函数睡眠，使程序睡眠n秒，在睡眠结束后就自动退出，不检测系统错误；</span><br><span class="line">mysplit程序：函数睡眠，使程序睡眠n秒，创建一个子进程进行睡眠，然后父进程等待子进程正常睡眠n秒后，继续运行；</span><br><span class="line">mystop程序：让进程暂定n秒，并发送信号。</span><br></pre></td></tr></table></figure>

<h2 id="三、实验内容"><a href="#三、实验内容" class="headerlink" title="三、实验内容"></a>三、实验内容</h2><h4 id="1-eval"><a href="#1-eval" class="headerlink" title="1.eval()"></a>1.eval()</h4><p><strong>函数功能</strong>：eval函数用于解析和解释命令行。eval首先解析命令行，如果用户请求一个内置命令quit、jobs、bg或fg（即内置命令）那么就立即执行。否则，fork子进程和在子进程的上下文中运行作业。如果作业正在运行前台，等待它终止，然后返回。</p>
<p><strong>函数原型</strong>：void eval(char *cmdline)，传入的参数为cmdline，即命令行字符串</p>
<p><strong>实现思路</strong>：仿照书上的eval函数写法和所需的功能来完成函数</p>
<p>1.首先调用parseline函数解析命令行，如果为空直接返回，接着使用builtin_cmd函数判断是否为内置命令，返回0说明不是内置命令，如果是内置命令直接执行。<br>2.如果不是内置命令，那么先阻塞信号（具体在第四点分析），再调用fork创建子进程。在子进程中，首先解除阻塞，设置自己的id号，然后调用execve函数来执行job。<br>3.父进程判断作业是否后台运行，是的话调用addjob函数将子进程job加入job链表中，解除阻塞，然后调用waifg函数等待前台运行完成。如果不在后台工作则打印进程组jid和子进程pid以及命令行字符串。<br>4.因为子进程继承了他们父进程的阻塞向量，所以在执行新程序之前，子程序必须确保解除对SIGCHLD信号的阻塞。父进程必须使用sigprocmask在它派生子进程之前也就是调用fork函数之前阻塞SIGCHLD信号，之后解除阻塞；在通过调用addjob将子进程添加到作业列表之后，再次使用sigprocmask，解除阻塞。</p>
<p><strong>完整代码</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">void eval(char *cmdline)</span><br><span class="line">&#123;</span><br><span class="line">    char *argv[MAXARGS];</span><br><span class="line">    int state = UNDEF;</span><br><span class="line">    sigset_t set;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    // 处理输入的数据</span><br><span class="line">    if (parseline(cmdline, argv) == 1)</span><br><span class="line">        state = BG;</span><br><span class="line">    else</span><br><span class="line">        state = FG;</span><br><span class="line">    if (argv[0] == NULL)</span><br><span class="line">        return;</span><br><span class="line">    // 如果不是内置命令</span><br><span class="line">    if (!builtin_cmd(argv))</span><br><span class="line">    &#123;</span><br><span class="line">        if (sigemptyset(&amp;set) &lt; 0)</span><br><span class="line">            unix_error(&quot;sigemptyset error&quot;);</span><br><span class="line">        if (sigaddset(&amp;set, SIGINT) &lt; 0 || sigaddset(&amp;set, SIGTSTP) &lt; 0 || sigaddset(&amp;set, SIGCHLD) &lt; 0)</span><br><span class="line">            unix_error(&quot;sigaddset error&quot;);</span><br><span class="line">        // 在fork前，将SIGCHLD信号阻塞，防止并发错误——_竞争_ 的发生</span><br><span class="line">        if (sigprocmask(SIG_BLOCK, &amp;set, NULL) &lt; 0)</span><br><span class="line">            unix_error(&quot;sigprocmask error&quot;);</span><br><span class="line"></span><br><span class="line">        if ((pid = fork()) &lt; 0)</span><br><span class="line">            unix_error(&quot;fork error&quot;);</span><br><span class="line">        else if (pid == 0)</span><br><span class="line">        &#123;</span><br><span class="line">            /*  把新建立的进程添加到新的进程组:</span><br><span class="line">                当从bash运行tsh时，tsh在bash前台进程组中运行。</span><br><span class="line">                如果tsh随后创建了一个子进程，默认情况下，该子进程也将是bash前台进程组的成员。</span><br><span class="line">                由于输入ctrl-c将向bash前台组中的每个进程发送一个SIGINT，</span><br><span class="line">                因此输入ctrl-c将向tsh以及tsh创建的每个进程发送一个SIGINT，这显然是不正确的。</span><br><span class="line">                这里有一个解决方案:在fork之后，但在execve之前，子进程应该调用setpgid(0,0)，</span><br><span class="line">                这将把子进程放入一个新的进程组中，该进程组的ID与子进程的PID相同。</span><br><span class="line">                这确保bash前台进程组中只有一个进程，即tsh进程。</span><br><span class="line">                当您键入ctrl-c时，tsh应该捕获结果SIGINT，然后将其转发到适当的前台作业</span><br><span class="line">            */</span><br><span class="line">            // 子进程的控制流开始</span><br><span class="line">            if (sigprocmask(SIG_UNBLOCK, &amp;set, NULL) &lt; 0)</span><br><span class="line">                unix_error(&quot;sigprocmask error&quot;);</span><br><span class="line">            if (setpgid(0, 0) &lt; 0)</span><br><span class="line">                unix_error(&quot;setpgid error&quot;);</span><br><span class="line">            if (execve(argv[0], argv, environ) &lt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                printf(&quot;%s: command not found\n&quot;, argv[0]);</span><br><span class="line">                exit(0);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 将当前进程添加进job中，无论是前台进程还是后台进程</span><br><span class="line">        addjob(jobs, pid, state, cmdline);</span><br><span class="line">        // 恢复受阻塞的信号 SIGINT SIGTSTP SIGCHLD</span><br><span class="line">        if (sigprocmask(SIG_UNBLOCK, &amp;set, NULL) &lt; 0)</span><br><span class="line">            unix_error(&quot;sigprocmask error&quot;);</span><br><span class="line"></span><br><span class="line">        // 判断子进程类型并做处理</span><br><span class="line">        if (state == FG)</span><br><span class="line">            waitfg(pid);</span><br><span class="line">        else</span><br><span class="line">            printf(&quot;[%d] (%d) %s&quot;, pid2jid(pid), pid, cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-builtin-cmd"><a href="#2-builtin-cmd" class="headerlink" title="2.builtin_cmd()"></a>2.builtin_cmd()</h4><p><strong>函数功能</strong>：识别并执行内置命令: quit, fg, bg, 和 jobs。</p>
<p><strong>函数原型</strong>：int builtin_cmd(char **argv)，参数为argv 参数列表</p>
<p><strong>实现思路</strong>：</p>
<p>当命令行参数为quit时，直接终止shell</p>
<p>当命令行参数为jobs时，调用listjobs函数，显示job列表</p>
<p>当命令行参数为bg或fg时，调用do_bgfg函数，执行内置的bg和fg命令</p>
<p>不是内置命令时返回0</p>
<p><strong>完整代码</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int builtin_cmd(char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    if (!strcmp(argv[0], &quot;quit&quot;))</span><br><span class="line">        exit(0);</span><br><span class="line">    else if (!strcmp(argv[0], &quot;bg&quot;) || !strcmp(argv[0], &quot;fg&quot;))</span><br><span class="line">        do_bgfg(argv);</span><br><span class="line">    else if (!strcmp(argv[0], &quot;jobs&quot;))</span><br><span class="line">        listjobs(jobs);</span><br><span class="line">    else</span><br><span class="line">        return 0; /* not a builtin command */</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-do-bgfg"><a href="#3-do-bgfg" class="headerlink" title="3.do_bgfg()"></a>3.do_bgfg()</h4><p><strong>函数功能</strong>：实现内置命令bg 和 fg</p>
<p>首先要明确的是bg和bg的作用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bg &lt;job&gt;:将停止的后台作业更改为正在运行的后台作业。</span><br><span class="line">通过发送SIGCONT信号重新启动&lt;job&gt;，然后在后台运行它。</span><br><span class="line">&lt;job&gt;参数可以是PID，也可以是JID。ST -&gt; BG</span><br><span class="line"></span><br><span class="line">fg &lt;job&gt;:将已停止或正在运行的后台作业更改为前台正在运行的作业。</span><br><span class="line">通过发送SIGCONT信号重新启&lt;job&gt;，然后在前台运行它。</span><br><span class="line">&lt;job&gt;参数可以是PID，也可以是JID。ST -&gt; FG，BG -&gt; FG</span><br></pre></td></tr></table></figure>

<p><strong>函数原型</strong>：void do_bgfg(char **argv)，参数为argv 参数列表</p>
<p><strong>实现思路</strong>：</p>
<p>判断argv[]是否带%，若为整数则传入pid，若带%则传入jid。接着调用getjobjid函数来获得对应的job结构体，如果返回为空，说明列表中并不存在jid的job，要输出提示。<br>使用strcmp函数判断是bg命令还是fg命令<br>若是bg，使目标进程重新开始工作，设置状态为BG(后台)，打印进程信息<br>若是fg，使目标进程重新开始工作，设置状态为FG(前台)，等待进程结束</p>
<p><strong>完整代码</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">void do_bgfg(char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    int parsed;</span><br><span class="line">    struct job_t *job;</span><br><span class="line">    // 没有参数的fg/bg应该被丢弃</span><br><span class="line">    if (!argv[1])</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%s command requires PID or %%jobid argument\n&quot;, argv[0]);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 检测fg/bg参数，其中%开头的数字是JobID，纯数字的是PID</span><br><span class="line">    if (argv[1][0] == &#x27;%&#x27;)</span><br><span class="line">    &#123;</span><br><span class="line">        if ((parsed = strtol(&amp;argv[1][1], NULL, 10)) &lt;= 0)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;%s: argument must be a PID or %%jobid\n&quot;, argv[0]);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if ((job = getjobjid(jobs, parsed)) == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;%%%d: No such job\n&quot;, parsed);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        if ((parsed = strtol(argv[1], NULL, 10)) &lt;= 0)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;%s: argument must be a PID or %%jobid\n&quot;, argv[0]);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if ((job = getjobpid(jobs, parsed)) == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;(%d): No such process\n&quot;, parsed);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!strcmp(argv[0], &quot;bg&quot;))</span><br><span class="line">    &#123;</span><br><span class="line">        // bg会启动子进程，并将其放置于后台执行</span><br><span class="line">        job-&gt;state = BG;</span><br><span class="line"></span><br><span class="line">        if (kill(-job-&gt;pid, SIGCONT) &lt; 0)</span><br><span class="line">            unix_error(&quot;kill error&quot;);</span><br><span class="line">        printf(&quot;[%d] (%d) %s&quot;, job-&gt;jid, job-&gt;pid, job-&gt;cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (!strcmp(argv[0], &quot;fg&quot;))</span><br><span class="line">    &#123;</span><br><span class="line">        job-&gt;state = FG;</span><br><span class="line">        if (kill(-job-&gt;pid, SIGCONT) &lt; 0)</span><br><span class="line">            unix_error(&quot;kill error&quot;);</span><br><span class="line">        // 当一个进程被设置为前台执行时，当前tsh应该等待该子进程结束</span><br><span class="line">        waitfg(job-&gt;pid);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        puts(&quot;do_bgfg: Internal error&quot;);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-waitfg（）"><a href="#4-waitfg（）" class="headerlink" title="4.waitfg（）"></a>4.waitfg（）</h4><p><strong>函数功能</strong>：等待一个前台作业结束，或者说是阻塞一个前台的进程直到这个进程变为后台进程</p>
<p><strong>函数原型</strong>：void waitfg(pid_t pid) ，参数为进程ID</p>
<p><strong>实现思路</strong>：判断当前的前台的进程组pid是否和当前进程的pid是否相等，如果相等则sleep直到前台进程结束。</p>
<p><strong>完整代码</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void waitfg(pid_t pid)</span><br><span class="line">&#123;</span><br><span class="line">    struct job_t *job = getjobpid(jobs, pid);</span><br><span class="line">    if (!job)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    // 如果当前子进程的状态没有发生改变，则tsh继续休眠</span><br><span class="line">    while (job-&gt;state == FG)</span><br><span class="line">        // 使用sleep的这段代码会比较慢，最好使用sigsuspend</span><br><span class="line">        sleep(1);</span><br><span class="line"></span><br><span class="line">    if (verbose)</span><br><span class="line">        printf(&quot;waitfg: Process (%d) no longer the fg process\n&quot;, pid);</span><br><span class="line"></span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-sigchld-handler"><a href="#5-sigchld-handler" class="headerlink" title="5.sigchld_handler()"></a>5.sigchld_handler()</h4><p><strong>函数功能</strong>：处理SIGCHILD信号 (Terminated or stopped child)</p>
<p><strong>函数原型</strong>：void sigchld_handler(int sig)，参数为信号类型</p>
<p>首先了解一下父进程回收子进程的过程：当一个子进程终止或者停止时，内核会发送一个SIGCHLD信号给父进程。因此父进程必须回收子进程，以避免在系统中留下僵死进程。父进程捕获这个SIGCHLD信号，回收一个子进程。一个进程可以通过调用 waitpid 函数来等待它的子进程终止或者停止。如果回收成功，则返回为子进程的 PID, 如果 WNOHANG, 则返回为 0, 如果其他错误，则为 -1。</p>
<p><strong>实现思路</strong>：</p>
<p>用while循环调用waitpid直到它所有的子进程终止。<br>检查己回收子进程的退出状态<br>    WIFSTOPPED：引起返回的子进程当前是被停止的<br>    WIFSIGNALED：子进程是因为一个未被捕获的信号终止<br>    WIFEXITED：子进程通过调用exit 或者return正常终止<br>然后分别用WSTOPSIG，WTERMSIG，WEXITSTATUS提取以上三个退出状态。注意如果引起返回的子进程当前是被停止的进程，那么要将其状态设置为ST<br>完整代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">void sigchld_handler(int sig)</span><br><span class="line">&#123;</span><br><span class="line">    int status, jid;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    struct job_t *job;</span><br><span class="line"></span><br><span class="line">    if (verbose)</span><br><span class="line">        puts(&quot;sigchld_handler: entering&quot;);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    以非阻塞方式等待所有子进程</span><br><span class="line">    waitpid 参数3：</span><br><span class="line">        1.     0     ： 执行waitpid时， 只有在子进程 **终止** 时才会返回。</span><br><span class="line">        2. WNOHANG   : 若子进程仍然在运行，则返回0 。</span><br><span class="line">                注意只有设置了这个标志，waitpid才有可能返回0</span><br><span class="line">        3. WUNTRACED : 如果子进程由于传递信号而停止，则马上返回。</span><br><span class="line">                只有设置了这个标志，waitpid返回时，其WIFSTOPPED(status)才有可能返回true</span><br><span class="line">    */</span><br><span class="line">    while ((pid = waitpid(-1, &amp;status, WNOHANG | WUNTRACED)) &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        // 如果当前这个子进程的job已经删除了，则表示有错误发生</span><br><span class="line">        if ((job = getjobpid(jobs, pid)) == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;Lost track of (%d)\n&quot;, pid);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        jid = job-&gt;jid;</span><br><span class="line">        // 如果这个子进程收到了一个暂停信号（还没退出</span><br><span class="line">        if (WIFSTOPPED(status))</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;Job [%d] (%d) stopped by signal %d\n&quot;, jid, job-&gt;pid, WSTOPSIG(status));</span><br><span class="line">            job-&gt;state = ST;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果这个子进程正常退出</span><br><span class="line">        else if (WIFEXITED(status))</span><br><span class="line">        &#123;</span><br><span class="line">            if (deletejob(jobs, pid))</span><br><span class="line">                if (verbose)</span><br><span class="line">                &#123;</span><br><span class="line">                    printf(&quot;sigchld_handler: Job [%d] (%d) deleted\n&quot;, jid, pid);</span><br><span class="line">                    printf(&quot;sigchld_handler: Job [%d] (%d) terminates OK (status %d)\n&quot;, jid, pid, WEXITSTATUS(status));</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果这个子进程因为其他的信号而异常退出，例如SIGKILL</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if (deletejob(jobs, pid))</span><br><span class="line">            &#123;</span><br><span class="line">                if (verbose)</span><br><span class="line">                    printf(&quot;sigchld_handler: Job [%d] (%d) deleted\n&quot;, jid, pid);</span><br><span class="line">            &#125;</span><br><span class="line">            printf(&quot;Job [%d] (%d) terminated by signal %d\n&quot;, jid, pid, WTERMSIG(status));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (verbose)</span><br><span class="line">        puts(&quot;sigchld_handler: exiting&quot;);</span><br><span class="line"></span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-sigint-handler"><a href="#6-sigint-handler" class="headerlink" title="6.sigint_handler()"></a>6.sigint_handler()</h4><p><strong>函数功能</strong>：捕获SIGINT信号 (ctrl-c)</p>
<p><strong>函数原型</strong>：void sigchld_handler(int sig)，参数为信号类型</p>
<p><strong>实现思路</strong>：</p>
<p>调用函数fgpid返回前台进程pid<br>如果当前进程pid不为0，那么调用kill函数发送SIGINT信号给前台进程组<br>在2中调用kill函数如果返回值为-1表示进程不存在。输出error<br><strong>完整代码</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void sigint_handler(int sig)</span><br><span class="line">&#123;</span><br><span class="line">    if (verbose)</span><br><span class="line">        puts(&quot;sigint_handler: entering&quot;);</span><br><span class="line">    pid_t pid = fgpid(jobs);</span><br><span class="line"></span><br><span class="line">    if (pid)</span><br><span class="line">    &#123;</span><br><span class="line">        // 发送SIGINT给前台进程组里的所有进程</span><br><span class="line">        // 需要注意的是，前台进程组内的进程除了当前前台进程以外，还包括前台进程的子进程。</span><br><span class="line">        // 最多只能存在一个前台进程，但前台进程组内可以存在多个进程</span><br><span class="line">        if (kill(-pid, SIGINT) &lt; 0)</span><br><span class="line">            unix_error(&quot;kill (sigint) error&quot;);</span><br><span class="line">        if (verbose)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;sigint_handler: Job (%d) killed\n&quot;, pid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (verbose)</span><br><span class="line">        puts(&quot;sigint_handler: exiting&quot;);</span><br><span class="line"></span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-sigtstp-handler"><a href="#7-sigtstp-handler" class="headerlink" title="7.sigtstp_handler()"></a>7.sigtstp_handler()</h4><p><strong>函数功能</strong>：同sigint_handler差不多，捕获SIGTSTP信号 (ctrl-z)</p>
<p><strong>函数原型</strong>：void sigtstp_handler(int sig) ，参数为信号类型</p>
<p>首先了解一下SIGTSTP的作用：SIGTSPT信号默认行为是停止直到下一个 SIGCONT，是来自终端的停止信号，在键盘上输入 CTR+Z会导致一个 SIGTSPT信号被发送到外壳。外壳捕获该信号，然后发送SIGTSPT信号到这个前台进程组中的每个进程。在默认情况下，结果是停止或挂起前台作业。</p>
<p><strong>实现思路</strong>：</p>
<p>用fgpid(jobs)获取前台进程pid，判断当前是否有前台进程，如果没有直接返回。<br>用kill(-pid,sig)函数发送SIGTSPT信号给前台进程组。<br><strong>完整代码</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void sigtstp_handler(int sig)</span><br><span class="line">&#123;</span><br><span class="line">    if (verbose)</span><br><span class="line">        puts(&quot;sigstp_handler: entering&quot;);</span><br><span class="line"></span><br><span class="line">    pid_t pid = fgpid(jobs);</span><br><span class="line">    struct job_t *job = getjobpid(jobs, pid);</span><br><span class="line"></span><br><span class="line">    if (pid)</span><br><span class="line">    &#123;</span><br><span class="line">        if (kill(-pid, SIGTSTP) &lt; 0)</span><br><span class="line">            unix_error(&quot;kill (tstp) error&quot;);</span><br><span class="line">        if (verbose)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;sigstp_handler: Job [%d] (%d) stopped\n&quot;, job-&gt;jid, pid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (verbose)</span><br><span class="line">        puts(&quot;sigstp_handler: exiting&quot;);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>至此tsh.c文件完成。</strong></p>
<h2 id="四、整体分析"><a href="#四、整体分析" class="headerlink" title="四、整体分析"></a>四、整体分析</h2><p>根据我们上面填写的代码，我们能够得出下面的函数调用关系图：</p>
<p><img src="/./img/2023-05-18-00-39-20-image.png"></p>
<p>接着，我们按着上面的流程图理一下程序是怎样运行的。</p>
<p><strong>首先看到main函数部分</strong></p>
<h4 id=""><a href="#" class="headerlink" title=""></a><img src="/./img/2023-05-17-22-23-49-image.png"></h4><p>main函数的前面是在进行一些初始化的操作，不用管。接着是一个while循环，读取.&#x2F;tsh命令后的选项，并根据选项打印帮助信息或者设置全局变量verbose的值（是否打印信息）和局部变量emit_prompt（发出提示）的值。</p>
<p>接着main函数调用了4个signal函数:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Signal(SIGINT, sigint_handler);   /* ctrl-c */</span><br><span class="line">Signal(SIGTSTP, sigtstp_handler); /* ctrl-z */</span><br><span class="line">Signal(SIGCHLD, sigchld_handler); /* Terminated or stopped child */</span><br><span class="line">/* This one provides a clean way to kill the shell */</span><br><span class="line">Signal(SIGQUIT, sigquit_handler);</span><br></pre></td></tr></table></figure>

<p>这些函数我们之后再讲，这里是安装信号处理函数。接着main函数调用initjobs函数，完成初始化任务列表的工作。initjobs函数不再详细分析。</p>
<p>接着进入一个while循环，这里就相当于已经进入了我们的tsh终端（shell），表示 Shell 的读取和执行命令的过程。第一个if就是打印tsh&gt;这一行标志shell的提示并刷新输出缓冲区。</p>
<p><img src="/./img/2023-05-17-22-34-48-image.png"></p>
<p>第二个if使用fgets函数从标准输入读取一行命令，并将其存储在 cmdline 数组中。</p>
<p>第三个if检查输入是否结束（Ctrl+D），如果是，则退出程序。</p>
<p>然后调用eval函数来解析和执行命令行。</p>
<p>刷新标准输出缓冲区，继续读取和执行下一个命令。</p>
<p>总的看来，main函数最重要的操作就是读取shell中的一行命令，并将其存储在 cmdline 数组中。之后调用了eval函数。</p>
<p><strong>我们看到eval函数</strong></p>
<p><img src="/./img/2023-05-17-22-44-06-image.png"></p>
<p>eavl函数在完成一些初始化的操作后就立即调用了parseline函数，下面是parseline的具体代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">int parseline(const char *cmdline, char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    static char array[MAXLINE]; /* holds local copy of command line */</span><br><span class="line">    char *buf = array;          /* ptr that traverses command line */</span><br><span class="line">    char *delim;                /* points to first space delimiter */</span><br><span class="line">    int argc;                   /* number of args */</span><br><span class="line">    int bg;                     /* background job? */</span><br><span class="line"></span><br><span class="line">    strcpy(buf, cmdline);</span><br><span class="line">    buf[strlen(buf) - 1] = &#x27; &#x27;;   /* replace trailing &#x27;\n&#x27; with space */</span><br><span class="line">    while (*buf &amp;&amp; (*buf == &#x27; &#x27;)) /* ignore leading spaces */</span><br><span class="line">        buf++;</span><br><span class="line"></span><br><span class="line">    /* Build the argv list */</span><br><span class="line">    argc = 0;</span><br><span class="line">    if (*buf == &#x27;\&#x27;&#x27;)</span><br><span class="line">    &#123;</span><br><span class="line">        buf++;</span><br><span class="line">        delim = strchr(buf, &#x27;\&#x27;&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        delim = strchr(buf, &#x27; &#x27;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (delim)</span><br><span class="line">    &#123;</span><br><span class="line">        argv[argc++] = buf;</span><br><span class="line">        *delim = &#x27;\0&#x27;;</span><br><span class="line">        buf = delim + 1;</span><br><span class="line">        while (*buf &amp;&amp; (*buf == &#x27; &#x27;)) /* ignore spaces */</span><br><span class="line">            buf++;</span><br><span class="line"></span><br><span class="line">        if (*buf == &#x27;\&#x27;&#x27;)</span><br><span class="line">        &#123;</span><br><span class="line">            buf++;</span><br><span class="line">            delim = strchr(buf, &#x27;\&#x27;&#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            delim = strchr(buf, &#x27; &#x27;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    argv[argc] = NULL;</span><br><span class="line"></span><br><span class="line">    if (argc == 0) /* ignore blank line */</span><br><span class="line">        return 1;</span><br><span class="line"></span><br><span class="line">    /* should the job run in the background? */</span><br><span class="line">    if ((bg = (*argv[argc - 1] == &#x27;&amp;&#x27;)) != 0)</span><br><span class="line">    &#123;</span><br><span class="line">        argv[--argc] = NULL;</span><br><span class="line">    &#125;</span><br><span class="line">    return bg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里parseline传入的参数是我们获取的一行命令以及argv数组，用于存储分割处理的命令。</p>
<p>首先将传入的命令行复制到buf中，即将命令行存储在本地副本中。然后将 buf中的换行符替换为空格，以便后续处理。接着忽略前导空格，即跳过命令行开头的空格。</p>
<p>将参数计数器 argc 初始化为0。判断命令行是否以单引号开头。如果是，则将 buf向后移动一位，并使用 strchr函数查找下一个单引号位置，赋值给 delim。如果不是，则使用 strchr函数查找下一个空格位置，赋值给 delim。</p>
<p>while (delim)循环解析命令行，直到没有分隔符（空格或单引号）为止。</p>
<ul>
<li>将 buf存储在argv中，并增加 argc的计数器。</li>
<li>将 delim设置为字符串结束符 \0，截断当前参数。</li>
<li>将 buf 指向delim的下一个字符，并跳过后续的空格。</li>
</ul>
<p>argv[argc] &#x3D; NULL;在参数列表的末尾添加一个空指针，表示参数的结束。</p>
<p>如果参数个数为0，表示输入的是空行，忽略处理，返回1。</p>
<p>检查最后一个参数是否为&amp;，判断命令是否应该在后台运行。如果是，则将 bg 标志位置为1，表示应该在后台运行，并将最后一个参数设置为NULL。如果不是，则将 bg 标志位置为0。最后返回 bg，表示命令是否应该在后台运行。</p>
<p><strong>简而言之，parseline这个函数的作用是判断传入进来的命令是否应该在后台运行，如果是就返回1，不是就返回0。并且完成了argv数组的填充，argv数组的内容是分割处理后的命令。例如：传入的命令是.&#x2F;myspin 1 &amp;。那么argv数组第一项的内容是.&#x2F;myspin，第二项是1，第三项是&amp;。</strong></p>
<p>回到eval函数，调用完parseline函数后我们就已经设置好了当前命令的状态（否是在后台运行），并且拿到了argv数组的内容。</p>
<p>接着eval函数调用了builtin_cmd函数，这个函数是用来判断我们输入的命令是不是内置命令。</p>
<p>如果不是我们就进入if判断创建子进程执行命令，并调用addjob将当前进程添加进job中（无论是前台进程还是后台进程）和waitfg判断子进程类型并做处理；</p>
<p>如果是就直接在builtin_cmd中完成处理。</p>
<p>完成处理后envl函数return回到main函数，刷新输出缓冲区，继续读取和执行下一个命令。</p>
<p><strong>接着我们来看命令不是内置命令的情况，即eval函数进入if判断。</strong></p>
<p><img src="/./img/2023-05-17-23-51-13-image.png"></p>
<p>接下来的3行if需要在fork前，将相关信号阻塞，防止并发错误竞争的发生。</p>
<p>    首先，使用sigemptyset函数初始化信号集set。</p>
<p>    然后使用 sigaddset 函数将 SIGINT、SIGTSTP 和 SIGCHLD 信号添加到 set中。</p>
<p>    使用 sigprocmask 函数将 set中的信号阻塞，以防止并发错误竞争。</p>
<p>然后我们才使用fork创建子进程来执行命令。</p>
<p>接下来的if就是子进程要执行的内容：由于fork出来的子进程和父进程是完全一致的，于是我们调用execve加载并执行命令行参数，这样就算是在真正创建一个子进程执行非内置命令。接下来调用addjob函数将当前的子进程加入任务列表中（无论是前台进程还是后台进程）。</p>
<p>但存在一个问题：当从bash运行tsh时，tsh在bash前台进程组中运行，如果tsh随后创建了一个子进程，默认情况下，该子进程也将是bash前台进程组的成员。由于输入ctrl-c将向bash前台组中的每个进程发送一个SIGINT，因此输入ctrl-c将向tsh以及tsh创建的每个进程发送一个SIGINT，这显然是不正确的，我们输入的SIGINT信号不该作用于父进程（tsh），而应该只作用于子进程。</p>
<p>这里有一个解决方案:在fork之后，但在execve之前，子进程调用setpgid(0,0)，这将把子进程放入一个新的进程组中，该进程组的ID与子进程的PID相同。确保bash前台进程组中只有一个进程，即tsh进程。当键入ctrl-c时，tsh应该捕获结果SIGINT，然后将其转发到适当的前台作业(我们的子进程)。</p>
<p>if后的addjob就是父进程要执行的内容了，而子进程无法执行。因为子进程使用execve后加载了具体的执行方案（？），这将覆盖掉继承自父进程的设定，其中包括set中的信号阻塞以及调用addjob。完成addjob后，父进程才能够恢复恢复受阻塞的信号 SIGINT SIGTSTP SIGCHLD，这是为了防止父进程还没将子进程加进任务列表，子进程就完成了执行并返还了一个结束的信号，否则会引发错误。</p>
<p><strong>如果子进程是前台进程</strong>，最后由父进程调用waitfg函数，作用是等待前台进程运行完毕。waitfg函数的具体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">void waitfg(pid_t pid)</span><br><span class="line">&#123;</span><br><span class="line">    struct job_t *job = getjobpid(jobs, pid);</span><br><span class="line">    if (!job)</span><br><span class="line">        return;</span><br><span class="line"></span><br><span class="line">    // 如果当前子进程的状态没有发生改变，则tsh继续休眠</span><br><span class="line">    while (job-&gt;state == FG)</span><br><span class="line">        // 使用sleep的这段代码会比较慢，最好使用sigsuspend</span><br><span class="line">        sleep(1);</span><br><span class="line"></span><br><span class="line">    if (verbose)</span><br><span class="line">        printf(&quot;waitfg: Process (%d) no longer the fg process\n&quot;, pid);</span><br><span class="line"></span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>waitfg函数传入的参数是子进程的pid，这里又调用了getjobpid，功能是根据pid找到对应的job，也就是我们处在任务列表中的子进程，如果子进程的状态没有发生改变，则tsh继续休眠（先睡一秒看看子进程状态变量没，没变接着睡一秒），睡醒了就打印信息说一下进程结束了，这时从waitfg回到eval再回到main，意味着我们在tsh中输入的那一条命令处理结束了（于前台进程执行的非内置命令）。刷新输出缓冲区，继续读取和执行下一个命令。</p>
<p>这里还要说明一下，这里的前台进程并不是tsh，我们做的只是让tsh睡眠，然后让子进程伪装成前台进程。</p>
<p><strong>如果子进程是后台进程</strong>，最后由父进程调用 pid2jid函数，作用是根据进程的pid找到jid。waitfg函数的具体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int pid2jid(pid_t pid)</span><br><span class="line">&#123;</span><br><span class="line">    int i;</span><br><span class="line"></span><br><span class="line">    if (pid &lt; 1)</span><br><span class="line">        return 0;</span><br><span class="line">    for (i = 0; i &lt; MAXJOBS; i++)</span><br><span class="line">        if (jobs[i].pid == pid)</span><br><span class="line">        &#123;</span><br><span class="line">            return jobs[i].jid;</span><br><span class="line">        &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时tsh打印这个进程的相关信息后，我们从eval再回到main，意味着我们在tsh中输入的那一条命令的处理结束了（于后台进程执行的非内置命令）。</p>
<p>这里还要说明一下，这里只是把子进程隐藏到了后台，让tsh变得可用，并不意味着这个进程就执行完毕了。</p>
<p><strong>前面我们分析了不是内置命令的情况，接下来我们来分析是内置命令的情况，即eval函数进入builtin_cmd直接处理。</strong></p>
<p><img src="/./img/2023-05-18-00-40-23-image.png"></p>
<p>如果是内置命令（quit&#x2F;bg&#x2F;fg&#x2F;jobs），我们直接跳到builtin_cmd函数处理，builtin_cmd的具体代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">int builtin_cmd(char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    if (!strcmp(argv[0], &quot;quit&quot;))</span><br><span class="line">        exit(0);</span><br><span class="line">    else if (!strcmp(argv[0], &quot;bg&quot;) || !strcmp(argv[0], &quot;fg&quot;))</span><br><span class="line">        do_bgfg(argv);</span><br><span class="line">    else if (!strcmp(argv[0], &quot;jobs&quot;))</span><br><span class="line">        listjobs(jobs);</span><br><span class="line">    else</span><br><span class="line">        return 0; /* not a builtin command */</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果输入的命令是quit，直接结束这个子进程，于是我们又回到经典的eval再回到main。</p>
<p>如果输入的命令是jobs，我们直接调用listjobs函数来打印任务列表。这里就不对listjobs函数进行详细分析了。</p>
<p>如果输入的命令是bg或者fg（bg：将停止的后台作业更改为正在运行的后台作业<br>fg :将已停止或正在运行的后台作业更改为前台正在运行的作业），我们调用do_bgfg函数来处理。do_bgfg函数的具体实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">void do_bgfg(char **argv)</span><br><span class="line">&#123;</span><br><span class="line">    int parsed;</span><br><span class="line">    struct job_t *job;</span><br><span class="line">    // 没有参数的fg/bg应该被丢弃</span><br><span class="line">    if (!argv[1])</span><br><span class="line">    &#123;</span><br><span class="line">        printf(&quot;%s command requires PID or %%jobid argument\n&quot;, argv[0]);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 检测fg/bg参数，其中%开头的数字是JobID，纯数字的是PID</span><br><span class="line">    if (argv[1][0] == &#x27;%&#x27;)</span><br><span class="line">    &#123;</span><br><span class="line">        if ((parsed = strtol(&amp;argv[1][1], NULL, 10)) &lt;= 0)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;%s: argument must be a PID or %%jobid\n&quot;, argv[0]);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if ((job = getjobjid(jobs, parsed)) == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;%%%d: No such job\n&quot;, parsed);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        if ((parsed = strtol(argv[1], NULL, 10)) &lt;= 0)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;%s: argument must be a PID or %%jobid\n&quot;, argv[0]);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if ((job = getjobpid(jobs, parsed)) == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;(%d): No such process\n&quot;, parsed);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!strcmp(argv[0], &quot;bg&quot;))</span><br><span class="line">    &#123;</span><br><span class="line">        // bg会启动子进程，并将其放置于后台执行</span><br><span class="line">        job-&gt;state = BG;</span><br><span class="line"></span><br><span class="line">        if (kill(-job-&gt;pid, SIGCONT) &lt; 0)</span><br><span class="line">            unix_error(&quot;kill error&quot;);</span><br><span class="line">        printf(&quot;[%d] (%d) %s&quot;, job-&gt;jid, job-&gt;pid, job-&gt;cmdline);</span><br><span class="line">    &#125;</span><br><span class="line">    else if (!strcmp(argv[0], &quot;fg&quot;))</span><br><span class="line">    &#123;</span><br><span class="line">        job-&gt;state = FG;</span><br><span class="line">        if (kill(-job-&gt;pid, SIGCONT) &lt; 0)</span><br><span class="line">            unix_error(&quot;kill error&quot;);</span><br><span class="line">        // 当一个进程被设置为前台执行时，当前tsh应该等待该子进程结束</span><br><span class="line">        waitfg(job-&gt;pid);</span><br><span class="line">    &#125;</span><br><span class="line">    else</span><br><span class="line">    &#123;</span><br><span class="line">        puts(&quot;do_bgfg: Internal error&quot;);</span><br><span class="line">        exit(0);</span><br><span class="line">    &#125;</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先我们丢弃没有参数的fg&#x2F;bg命令。然后检测fg&#x2F;bg参数，其中%开头的数字是jid，纯数字的是pid，并参数中的数字部分解析为整数 parsed，如果通过pid无法找到对应的任务，则输出错误信息并返回。</p>
<p>然后我们需要根据命令是 bg 还是 fg 进行不同的处理：</p>
<p>如果是 bg 命令：</p>
<ul>
<li>将作业状态设置为后台执行（bg）。</li>
<li>使用 kill 函数发送 SIGCONT 信号给任务的进程组（我们的子进程），以使其恢复执行。</li>
<li>输出作业的信息（jid、pid、命令）。</li>
</ul>
<p>同之前分析的差不多，这里也是子进程（于后台进程执行的内置命令）隐藏到了后台，让tsh变得可用，并不意味着这个进程就执行完毕了。</p>
<p>如果是 fg 命令：</p>
<ul>
<li>将作业状态设置为前台执行（fg）。</li>
<li>使用 kill函数发送 SIGCONT信号给任务的进程组（我们的子进程），以使其恢复执行。</li>
<li>调用 waitfg 函数等待前台作业完成。</li>
</ul>
<p>关于我们的waitfg函数前面已经分析过了。在这里我们同样也是等待进程结束（于前台进程执行的内置命令），一旦进程结束，我们就从waitfg回到do_bgfg再回到builtin_cmd再回到eval最后回到main(很他妈牛逼)，然后就是经典的刷新输出缓冲区，继续读取和执行下一个命令。</p>
<p>如果命令既不是 bg 也不是 fg，则输出错误信息并退出。</p>
<p><strong>至此，我们的主线任务就已经全部完成了，然后我们开始支线任务：信号处理</strong></p>
<p><img src="/./img/2023-05-18-11-07-25-image.png"></p>
<p><strong>首先是我们的SIGCHILD信号，处理这个信号的函数是sigchld_handler。</strong></p>
<p>这个信号在进程回收子进程的过程中出现：当一个子进程终止或者停止时，内核会发送一个SIGCHLD信号给父进程。因此父进程必须回收子进程，以避免在系统中留下僵死进程。父进程捕获这个SIGCHLD信号，回收一个子进程。一个进程可以通过调用 waitpid 函数来等待它的子进程终止或者停止。如果回收成功，则返回为子进程的 PID, 如果 WNOHANG, 则返回为 0, 如果其他错误，则为 -1。<br>下面是sigchld_handler函数的具体实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">void sigchld_handler(int sig)</span><br><span class="line">&#123;</span><br><span class="line">    int status, jid;</span><br><span class="line">    pid_t pid;</span><br><span class="line">    struct job_t *job;</span><br><span class="line"></span><br><span class="line">    if (verbose)</span><br><span class="line">        puts(&quot;sigchld_handler: entering&quot;);</span><br><span class="line"></span><br><span class="line">    /*</span><br><span class="line">    以非阻塞方式等待所有子进程</span><br><span class="line">    waitpid 参数3：</span><br><span class="line">        1.     0     ： 执行waitpid时， 只有在子进程 **终止** 时才会返回。</span><br><span class="line">        2. WNOHANG   : 若子进程仍然在运行，则返回0 。</span><br><span class="line">                注意只有设置了这个标志，waitpid才有可能返回0</span><br><span class="line">        3. WUNTRACED : 如果子进程由于传递信号而停止，则马上返回。</span><br><span class="line">                只有设置了这个标志，waitpid返回时，其WIFSTOPPED(status)才有可能返回true</span><br><span class="line">    */</span><br><span class="line">    while ((pid = waitpid(-1, &amp;status, WNOHANG | WUNTRACED)) &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        // 如果当前这个子进程的job已经删除了，则表示有错误发生</span><br><span class="line">        if ((job = getjobpid(jobs, pid)) == NULL)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;Lost track of (%d)\n&quot;, pid);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        jid = job-&gt;jid;</span><br><span class="line">        // 如果这个子进程收到了一个暂停信号（还没退出</span><br><span class="line">        if (WIFSTOPPED(status))</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;Job [%d] (%d) stopped by signal %d\n&quot;, jid, job-&gt;pid, WSTOPSIG(status));</span><br><span class="line">            job-&gt;state = ST;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果这个子进程正常退出</span><br><span class="line">        else if (WIFEXITED(status))</span><br><span class="line">        &#123;</span><br><span class="line">            if (deletejob(jobs, pid))</span><br><span class="line">                if (verbose)</span><br><span class="line">                &#123;</span><br><span class="line">                    printf(&quot;sigchld_handler: Job [%d] (%d) deleted\n&quot;, jid, pid);</span><br><span class="line">                    printf(&quot;sigchld_handler: Job [%d] (%d) terminates OK (status %d)\n&quot;, jid, pid, WEXITSTATUS(status));</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 如果这个子进程因为其他的信号而异常退出，例如SIGKILL</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            if (deletejob(jobs, pid))</span><br><span class="line">            &#123;</span><br><span class="line">                if (verbose)</span><br><span class="line">                    printf(&quot;sigchld_handler: Job [%d] (%d) deleted\n&quot;, jid, pid);</span><br><span class="line">            &#125;</span><br><span class="line">            printf(&quot;Job [%d] (%d) terminated by signal %d\n&quot;, jid, pid, WTERMSIG(status));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (verbose)</span><br><span class="line">        puts(&quot;sigchld_handler: exiting&quot;);</span><br><span class="line"></span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数一开始的还是一些初始化的操作，打印调试信息。</p>
<p>接着使用 waitpid 函数以非阻塞方式等待所有子进程的状态变化：</p>
<ul>
<li>-1 表示等待任何子进程。</li>
<li>使用 <code>WNOHANG</code> 标志告诉 waitpid 在没有可用子进程状态时立即返回。</li>
<li>使用 <code>WUNTRACED</code> 标志告诉 waitpid 在子进程由于接收到信号而停止时立即返回。</li>
</ul>
<p>那么这里的意思大概是是等待所有子进程，直到子进程结束。</p>
<p>然后进入循环，处理等待到的子进程：</p>
<ul>
<li>如果 waitpid 返回的进程ID小于等于0，则表示没有更多的子进程需要处理，跳出循环。</li>
<li>如果通过进程ID无法找到对应的任务信息，则输出错误信息，并返回。</li>
<li>获取任务的 jid。</li>
<li>如果子进程收到了一个暂停信号（还没有退出）：<ul>
<li>输出作业暂停的信息，包括作业ID、进程ID和接收到的信号。</li>
<li>将作业状态设置为停止（ST）。</li>
</ul>
</li>
<li>如果子进程正常退出：<ul>
<li>删除作业，并根据设置的 verbose 标志输出调试信息。</li>
</ul>
</li>
<li>如果子进程因其他信号异常退出：<ul>
<li>删除作业，并输出作业终止的信息，包括作业ID、进程ID和终止的信号。</li>
</ul>
</li>
</ul>
<p><strong>接下来来看我们的SIGINT(ctrl-c)信号，处理这个信号的函数是sigint_handler。</strong></p>
<p>我们在前面提到过这样一个问题：</p>
<p>当从bash运行tsh时，tsh在bash前台进程组中运行，如果tsh随后创建了一个子进程，默认情况下，该子进程也将是bash前台进程组的成员。由于输入ctrl-c将向bash前台组中的每个进程发送一个SIGINT，因此输入ctrl-c将向tsh以及tsh创建的每个进程发送一个SIGINT，这显然是不正确的，我们输入的SIGINT信号不该作用于父进程（tsh），而应该只作用于子进程。</p>
<p>也说到了对应的解决方案：</p>
<p>在fork之后，但在execve之前，子进程调用setpgid(0,0)，这将把子进程放入一个新的进程组中，该进程组的ID与子进程的PID相同。确保bash前台进程组中只有一个进程，即tsh进程。当键入ctrl-c时，tsh应该捕获结果SIGINT，然后将其转发到适当的前台作业(我们的子进程)。</p>
<p>这里我们要实现的sigint_handler函数就是： ‘tsh应该捕获结果SIGINT，然后将其转发到适当的前台作业’  这一个过程。</p>
<p>sigint_handler函数的具体实现如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">void sigint_handler(int sig)</span><br><span class="line">&#123;</span><br><span class="line">    if (verbose)</span><br><span class="line">        puts(&quot;sigint_handler: entering&quot;);</span><br><span class="line">    pid_t pid = fgpid(jobs);</span><br><span class="line"></span><br><span class="line">    if (pid)</span><br><span class="line">    &#123;</span><br><span class="line">        // 发送SIGINT给前台进程组里的所有进程</span><br><span class="line">        // 需要注意的是，前台进程组内的进程除了当前前台进程以外，还包括前台进程的子进程。</span><br><span class="line">        // 最多只能存在一个前台进程，但前台进程组内可以存在多个进程</span><br><span class="line">        if (kill(-pid, SIGINT) &lt; 0)</span><br><span class="line">            unix_error(&quot;kill (sigint) error&quot;);</span><br><span class="line">        if (verbose)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;sigint_handler: Job (%d) killed\n&quot;, pid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (verbose)</span><br><span class="line">        puts(&quot;sigint_handler: exiting&quot;);</span><br><span class="line"></span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>首先输出调试信息，并使用 fgpid 函数获取当前前台任务的pid。</p>
<p>如果 pid 不为0，表示存在前台作业（前台进程组）：</p>
<ul>
<li>使用 kill 函数向前台进程组中的所有进程发送 SIGINT 信号。</li>
<li>通过传递负的进程ID参数 -pid，将信号发送给进程组中的所有进程。</li>
<li>如果 kill 函数返回值小于0，则表示发送信号失败，输出错误信息。</li>
<li>如果设置了verbose标志，输出调试信息：被杀死的作业的进程ID。</li>
</ul>
<p>最后打印”sigint_handler: exiting”，提一嘴这个SIGINT 信号已经处理完毕。</p>
<p>我们来看一个例子：如果我们的父进程(tsh)收到了一个ctrl-c的信号，父进程会将这个信号转给子进程，子进程收到这个信号后子进程所在的进程组的所有进程都会被终止，相当于父进程诛连了子进程九族（？按常理来说，父亲应该是在九族中的），然后子进程被自杀（？其实是终止或者停止）时，子进程通过内核给父进程发送一个SIGCHLD信号，然后就跳到我们的sigchld_handler函数，父进程要对子进程进行一些处理了。首先父进程要判断等待处理的子进程的状态，这里我们的子进程是被暂停了，sigchld_handler中就会打印提示信息说该任务被暂停了，随后将子进程的状态设置成stopped(ST)。</p>
<p>如果子进程不是被暂停了，而是运行结束或者运行出错了，那么在上面的基础上，sigchld_handler还会调用deletejob删除子进程的任务。</p>
<p><strong>最后是我们的SIGTSTP(ctrl-z)信号，处理这个信号的函数是sigtstp_handler。</strong></p>
<p>SIGTSTP的作用：SIGTSPT信号默认行为是停止直到下一个 SIGCONT，是来自终端的停止信号，在键盘上输入 CTR+Z会导致一个 SIGTSPT信号被发送到外壳。外壳捕获该信号，然后发送SIGTSPT信号到这个前台进程组中的每个进程。在默认情况下，结果是停止或挂起前台作业。下面是sigtstp_handler函数的具体实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">void sigtstp_handler(int sig)</span><br><span class="line">&#123;</span><br><span class="line">    if (verbose)</span><br><span class="line">        puts(&quot;sigstp_handler: entering&quot;);</span><br><span class="line"></span><br><span class="line">    pid_t pid = fgpid(jobs);</span><br><span class="line">    struct job_t *job = getjobpid(jobs, pid);</span><br><span class="line"></span><br><span class="line">    if (pid)</span><br><span class="line">    &#123;</span><br><span class="line">        if (kill(-pid, SIGTSTP) &lt; 0)</span><br><span class="line">            unix_error(&quot;kill (tstp) error&quot;);</span><br><span class="line">        if (verbose)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot;sigstp_handler: Job [%d] (%d) stopped\n&quot;, job-&gt;jid, pid);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (verbose)</span><br><span class="line">        puts(&quot;sigstp_handler: exiting&quot;);</span><br><span class="line">    return;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其实sigtstp_handler和sigint_handler的具体组成完全可以说是一模一样，唯一的区别就是调用kill函数时的参数，sigtstp_handler中kill的参数是SIGTSTP，完成将SIGTSTP信号传给父进程（tsh）。接下来的步骤就和上面一样了，父进程把信号传给子进程，子进程作出反应后把信号传给父进程，父进程处理子进程，结束。</p>
<p><strong>以上就是信号处理的全部部分了，也算是把tsh.c文件完整地过了一遍。</strong></p>
<h2 id="五、关卡分析"><a href="#五、关卡分析" class="headerlink" title="五、关卡分析"></a>五、关卡分析</h2><h4 id="第一关"><a href="#第一关" class="headerlink" title="第一关"></a>第一关</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line"># trace01.txt - Properly terminate on EOF.</span><br><span class="line">#</span><br><span class="line">CLOSE</span><br><span class="line">WAIT</span><br></pre></td></tr></table></figure>

<p>调用了linux命令close关闭文件并wait等待，在EOF上正常终止，所以不需要我们做任何事</p>
<h4 id="第二关"><a href="#第二关" class="headerlink" title="第二关"></a>第二关</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line"># trace02.txt - Process builtin quit command.</span><br><span class="line">#</span><br><span class="line">quit</span><br><span class="line">WAIT</span><br></pre></td></tr></table></figure>

<p>tsh执行内置命令quit。</p>
<h4 id="第三关"><a href="#第三关" class="headerlink" title="第三关"></a>第三关</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line"># trace03.txt - Run a foreground job.</span><br><span class="line">#</span><br><span class="line">/bin/echo tsh&gt; quit</span><br><span class="line">quit</span><br></pre></td></tr></table></figure>

<p>打开 bin 目录下的 echo 可执行文件，在 foregound 开启一个子进程运行它。运行 echo 这个进程的过程中，通过 tsh&gt;quit 命令，调用 tsh并执行内置命令 quit，退出 echo 这个子进程。最后在 tsh 中执行内置命令 quit，退出 tsh 进程，回到我们的终端。</p>
<p>前台进程执行的非内置命令。</p>
<h2 id="第四关"><a href="#第四关" class="headerlink" title="第四关"></a>第四关</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line"># trace04.txt - Run a background job.</span><br><span class="line">#</span><br><span class="line">/bin/echo -e tsh&gt; ./myspin 1 \046</span><br><span class="line">./myspin 1 &amp;</span><br></pre></td></tr></table></figure>

<p>先在前台执行echo命令，等待程序执行完毕回收子进程。&amp;代表是一个后台程序，myspin睡眠1秒，然后停止。因为在后台，所以显示下面一句，如果在前台则无。</p>
<p>后台进程执行的非内置命令。</p>
<h4 id="第五关"><a href="#第五关" class="headerlink" title="第五关"></a>第五关</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line"># trace05.txt - Process jobs builtin command.</span><br><span class="line">#</span><br><span class="line">/bin/echo -e tsh&gt; ./myspin 2 \046</span><br><span class="line">./myspin 2 &amp;</span><br><span class="line"></span><br><span class="line">/bin/echo -e tsh&gt; ./myspin 3 \046</span><br><span class="line">./myspin 3 &amp;</span><br><span class="line"></span><br><span class="line">/bin/echo tsh&gt; jobs</span><br><span class="line">jobs</span><br></pre></td></tr></table></figure>

<p>分别运行了前台echo、后台myspin、前台echo、后台myspin，然后需要实现一个内置命令job，功能是显示目前任务列表中的所有任务的所有属性。但相比前面的test只多了一个jobs命令需要实现。</p>
<p>tsh执行内置命令jobs。</p>
<h4 id="第六关"><a href="#第六关" class="headerlink" title="第六关"></a>第六关</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line"># trace06.txt - Forward SIGINT to foreground job.</span><br><span class="line">#</span><br><span class="line">/bin/echo -e tsh&gt; ./myspin 4</span><br><span class="line">./myspin 4 </span><br><span class="line"></span><br><span class="line">SLEEP 2</span><br><span class="line">INT</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个test是接收到了中断信号SIGINT（即CTRL_C)，那么结束前台进程</p>
<p>实现信号SIGINT。</p>
<h4 id="第七关"><a href="#第七关" class="headerlink" title="第七关"></a>第七关</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line"># trace07.txt - Forward SIGINT only to foreground job.</span><br><span class="line">#</span><br><span class="line">/bin/echo -e tsh&gt; ./myspin 4 \046</span><br><span class="line">./myspin 4 &amp;</span><br><span class="line"></span><br><span class="line">/bin/echo -e tsh&gt; ./myspin 5</span><br><span class="line">./myspin 5 </span><br><span class="line"></span><br><span class="line">SLEEP 2</span><br><span class="line">INT</span><br><span class="line"></span><br><span class="line">/bin/echo tsh&gt; jobs</span><br><span class="line">jobs</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>根据注释，我们可以知道第七关测试的是只将SIGINT转发给前台作业。这里的命令行其实根据前面的就很好理解了，就是给出两个作业，一个在前台工作，另一个在后台工作，接下来传递SIGINT指令，然后调用内置指令jobs来查看此时的工作信息，来对比出是不是只将SIGINT转发给前台作业。</p>
<p>处理信号SIGINT。</p>
<h4 id="第八关"><a href="#第八关" class="headerlink" title="第八关"></a>第八关</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line"># trace08.txt - Forward SIGTSTP only to foreground job.</span><br><span class="line">#</span><br><span class="line">/bin/echo -e tsh&gt; ./myspin 4 \046</span><br><span class="line">./myspin 4 &amp;</span><br><span class="line"></span><br><span class="line">/bin/echo -e tsh&gt; ./myspin 5</span><br><span class="line">./myspin 5 </span><br><span class="line"></span><br><span class="line">SLEEP 2</span><br><span class="line">TSTP</span><br><span class="line"></span><br><span class="line">/bin/echo tsh&gt; jobs</span><br><span class="line">jobs</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>根据注释我们是需要将SIGTSTP转发给前台作业。根据这个信号的作用，也就是该进程会停止直到下一个SIGCONT也就是挂起，让别的程序继续运行。这里也就是运行了后台程序，然后使用jobs来打印出进程的信息。</p>
<p>实现并处理SIGTSTP信号。</p>
<h4 id="第九关"><a href="#第九关" class="headerlink" title="第九关"></a>第九关</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line"># trace09.txt - Process bg builtin command</span><br><span class="line">#</span><br><span class="line">/bin/echo -e tsh&gt; ./myspin 4 \046</span><br><span class="line">./myspin 4 &amp;</span><br><span class="line"></span><br><span class="line">/bin/echo -e tsh&gt; ./myspin 5</span><br><span class="line">./myspin 5 </span><br><span class="line"></span><br><span class="line">SLEEP 2</span><br><span class="line">TSTP</span><br><span class="line"></span><br><span class="line">/bin/echo tsh&gt; jobs</span><br><span class="line">jobs</span><br><span class="line"></span><br><span class="line">/bin/echo tsh&gt; bg %2</span><br><span class="line">bg %2</span><br><span class="line"></span><br><span class="line">/bin/echo tsh&gt; jobs</span><br><span class="line">jobs</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里是在第八关的测试文件之上的一个更加完整的测试，这里也就是在停止后，输出进程信息之后，使用bg命令来唤醒进程2，也就是刚才被挂起的程序，接下来继续使用Jobs命令来输出结果。</p>
<p>子进程（于后台进程执行的内置命令）隐藏到了后台，让tsh变得可用。</p>
<h4 id="第十关"><a href="#第十关" class="headerlink" title="第十关"></a>第十关</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line"># trace10.txt - Process fg builtin command. </span><br><span class="line">#</span><br><span class="line">/bin/echo -e tsh&gt; ./myspin 4 \046</span><br><span class="line">./myspin 4 &amp;</span><br><span class="line"></span><br><span class="line">SLEEP 1</span><br><span class="line">/bin/echo tsh&gt; fg %1</span><br><span class="line">fg %1</span><br><span class="line"></span><br><span class="line">SLEEP 1</span><br><span class="line">TSTP</span><br><span class="line"></span><br><span class="line">/bin/echo tsh&gt; jobs</span><br><span class="line">jobs</span><br><span class="line"></span><br><span class="line">/bin/echo tsh&gt; fg %1</span><br><span class="line">fg %1</span><br><span class="line"></span><br><span class="line">/bin/echo tsh&gt; jobs</span><br><span class="line">jobs</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这里是将后台的进程更改为前台正在运行的程序。测试文中进程1根据&amp;可以知道，进程1是一个后台进程。先使用fg命令将其转化为前台的一个程序，接下来停止进程1，然后打印出进程信息，这时候进程1应该是前台程序同时被挂起了，接下来使用fg命令使其继续运行，使用jobs来打印出进程信息</p>
<p>等待进程结束（于前台进程执行的内置命令）</p>
<h4 id="第十一关"><a href="#第十一关" class="headerlink" title="第十一关"></a>第十一关</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line"># trace11.txt - Forward SIGINT to every process in foreground process group</span><br><span class="line">#</span><br><span class="line">/bin/echo -e tsh&gt; ./mysplit 4</span><br><span class="line">./mysplit 4 </span><br><span class="line"></span><br><span class="line">SLEEP 2</span><br><span class="line">INT</span><br><span class="line"></span><br><span class="line">/bin/echo tsh&gt; /bin/ps a</span><br><span class="line">/bin/ps a</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>根据注释我们可以知道这里需要将SIGINT发给前台进程组中的每个进程。ps –a 显示所有进程，这里是有两个进程的，mysplit创建了一个子进程，接下来发送指令SIGINT，所以进程组中的所有进程都应该停止，接下来调用pl来查看该进程组中的每个进程是否都停止了。</p>
<p>同第七关，处理信号SIGINT（更加完善）。</p>
<h4 id="第十二关"><a href="#第十二关" class="headerlink" title="第十二关"></a>第十二关</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line"># trace12.txt - Forward SIGTSTP to every process in foreground process group</span><br><span class="line">#</span><br><span class="line">/bin/echo -e tsh&gt; ./mysplit 4</span><br><span class="line">./mysplit 4 </span><br><span class="line"></span><br><span class="line">SLEEP 2</span><br><span class="line">TSTP</span><br><span class="line"></span><br><span class="line">/bin/echo tsh&gt; jobs</span><br><span class="line">jobs</span><br><span class="line"></span><br><span class="line">/bin/echo tsh&gt; /bin/ps a</span><br><span class="line">/bin/ps a</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>根据注释可知该测试程序是为了测试将SIGTSTP转发给前台进程组中的每个进程。与上一关相同，只需要相应的进程被挂起即可。</p>
<p>同第八关，处理SIGTSTP信号（更加完善）。</p>
<h4 id="第十三关"><a href="#第十三关" class="headerlink" title="第十三关"></a>第十三关</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line"># trace13.txt - Restart every stopped process in process group</span><br><span class="line">#</span><br><span class="line">/bin/echo -e tsh&gt; ./mysplit 4</span><br><span class="line">./mysplit 4 </span><br><span class="line"></span><br><span class="line">SLEEP 2</span><br><span class="line">TSTP</span><br><span class="line"></span><br><span class="line">/bin/echo tsh&gt; jobs</span><br><span class="line">jobs</span><br><span class="line"></span><br><span class="line">/bin/echo tsh&gt; /bin/ps a</span><br><span class="line">/bin/ps a</span><br><span class="line"></span><br><span class="line">/bin/echo tsh&gt; fg %1</span><br><span class="line">fg %1</span><br><span class="line"></span><br><span class="line">/bin/echo tsh&gt; /bin/ps a</span><br><span class="line">/bin/ps a</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>根据注释我们可以知道该程序是为了测试重新启动进程组中的每个停止的进程。这里也就是使用fg来唤醒整个工作，中间使用ps -a来查看停止整个工作和唤醒整个工作的区别。</p>
<p>同第十关，等待进程组结束（于前台进程执行的内置命令）</p>
<h4 id="第十四关"><a href="#第十四关" class="headerlink" title="第十四关"></a>第十四关</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line"># trace14.txt - Simple error handling</span><br><span class="line">#</span><br><span class="line">/bin/echo tsh&gt; ./bogus</span><br><span class="line">./bogus</span><br><span class="line"></span><br><span class="line">/bin/echo -e tsh&gt; ./myspin 4 \046</span><br><span class="line">./myspin 4 &amp;</span><br><span class="line"></span><br><span class="line">/bin/echo tsh&gt; fg</span><br><span class="line">fg</span><br><span class="line"></span><br><span class="line">/bin/echo tsh&gt; bg</span><br><span class="line">bg</span><br><span class="line"></span><br><span class="line">/bin/echo tsh&gt; fg a</span><br><span class="line">fg a</span><br><span class="line"></span><br><span class="line">/bin/echo tsh&gt; bg a</span><br><span class="line">bg a</span><br><span class="line"></span><br><span class="line">/bin/echo tsh&gt; fg 9999999</span><br><span class="line">fg 9999999</span><br><span class="line"></span><br><span class="line">/bin/echo tsh&gt; bg 9999999</span><br><span class="line">bg 9999999</span><br><span class="line"></span><br><span class="line">/bin/echo tsh&gt; fg %2</span><br><span class="line">fg %2</span><br><span class="line"></span><br><span class="line">/bin/echo tsh&gt; fg %1</span><br><span class="line">fg %1</span><br><span class="line"></span><br><span class="line">SLEEP 2</span><br><span class="line">TSTP</span><br><span class="line"></span><br><span class="line">/bin/echo tsh&gt; bg %2</span><br><span class="line">bg %2</span><br><span class="line"></span><br><span class="line">/bin/echo tsh&gt; bg %1</span><br><span class="line">bg %1</span><br><span class="line"></span><br><span class="line">/bin/echo tsh&gt; jobs</span><br><span class="line">jobs</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>根据注释可以知道这个文件是为了测试简单的错误处理。这里的测试文件，也就是测试fg和bg后面的参数，我们知道fg和bg后面需要一个JID或者是PID，其中JID是加上%的整型数。其余参数都应该报错，或是没有参数也应该报错。接下来测试的功能，都在上面的关卡测试过了</p>
<h4 id="第十五关"><a href="#第十五关" class="headerlink" title="第十五关"></a>第十五关</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line"># trace15.txt - Putting it all together</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">/bin/echo tsh&gt; ./bogus</span><br><span class="line">./bogus</span><br><span class="line"></span><br><span class="line">/bin/echo tsh&gt; ./myspin 10</span><br><span class="line">./myspin 10</span><br><span class="line"></span><br><span class="line">SLEEP 2</span><br><span class="line">INT</span><br><span class="line"></span><br><span class="line">/bin/echo -e tsh&gt; ./myspin 3 \046</span><br><span class="line">./myspin 3 &amp;</span><br><span class="line"></span><br><span class="line">/bin/echo -e tsh&gt; ./myspin 4 \046</span><br><span class="line">./myspin 4 &amp;</span><br><span class="line"></span><br><span class="line">/bin/echo tsh&gt; jobs</span><br><span class="line">jobs</span><br><span class="line"></span><br><span class="line">/bin/echo tsh&gt; fg %1</span><br><span class="line">fg %1</span><br><span class="line"></span><br><span class="line">SLEEP 2</span><br><span class="line">TSTP</span><br><span class="line"></span><br><span class="line">/bin/echo tsh&gt; jobs</span><br><span class="line">jobs</span><br><span class="line"></span><br><span class="line">/bin/echo tsh&gt; bg %3</span><br><span class="line">bg %3</span><br><span class="line"></span><br><span class="line">/bin/echo tsh&gt; bg %1</span><br><span class="line">bg %1</span><br><span class="line"></span><br><span class="line">/bin/echo tsh&gt; jobs</span><br><span class="line">jobs</span><br><span class="line"></span><br><span class="line">/bin/echo tsh&gt; fg %1</span><br><span class="line">fg %1</span><br><span class="line"></span><br><span class="line">/bin/echo tsh&gt; quit</span><br><span class="line">quit</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>根据注释这个测试文件测试的是把它们放在一起。可以知道他是测试了上述所有命令，如jobs,fg,bg,quit。</p>
<h4 id="第十六题"><a href="#第十六题" class="headerlink" title="第十六题"></a>第十六题</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line"># trace16.txt - Tests whether the shell can handle SIGTSTP and SIGINT</span><br><span class="line">#     signals that come from other processes instead of the terminal.</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">/bin/echo tsh&gt; ./mystop 2 </span><br><span class="line">./mystop 2</span><br><span class="line"></span><br><span class="line">SLEEP 3</span><br><span class="line"></span><br><span class="line">/bin/echo tsh&gt; jobs</span><br><span class="line">jobs</span><br><span class="line"></span><br><span class="line">/bin/echo tsh&gt; ./myint 2 </span><br><span class="line">./myint 2</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这个测试文件的具体含义就是，用户程序向job 2传送了中止信号，所以最后会输出进程2被中止的信息。同时，mystop需要自己停止才能给别的进程发送信号，所以中间也会出现进程1被中止的信息。</p>


                
            </div>

            <!-- Comments -->
            
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    


                </div>
            
        </div>
    </div>
</article>

    <!-- Footer -->
    <hr />

<!-- Footer -->
<footer>
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                <ul class="list-inline text-center">
                    

                    

                    
                        <li>
                            <a href="https://github.com/klugjo/hexo-theme-clean-blog" target="_blank">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    

                    

                    

                    
                </ul>
                <p class="copyright text-muted">&copy; 2023 cloud<br></p>
                <p class="copyright text-muted">Original Theme <a target="_blank" href="http://startbootstrap.com/template-overviews/clean-blog/">Clean Blog</a> from <a href="http://startbootstrap.com/" target="_blank">Start Bootstrap</a></p>
                <p class="copyright text-muted">Adapted for <a target="_blank" href="https://hexo.io/">Hexo</a> by <a href="http://www.codeblocq.com/" target="_blank">Jonathan Klughertz</a></p>
            </div>
        </div>
    </div>
</footer>


    <!-- After footer scripts -->
    
<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Bootstrap -->
<script src="//maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Disqus Comments -->



</body>

</html>